use proc_macro2::TokenStream;
use prost::Message;
use prost_build::Module;
use prost_reflect::DescriptorPool;
use prost_types::compiler::code_generator_response::File;
use prost_validate_build::Builder;
use protoc_gen_prost::{Error, Generator, ModuleRequest, ModuleRequestSet, Result};
use std::collections::HashMap;
use syn::__private::ToTokens;

pub struct ProstValidateGenerator {
    builder: Builder,
    config: prost_build::Config,
    insert_include: bool,
}

impl Generator for ProstValidateGenerator {
    fn generate(&mut self, module_request_set: &ModuleRequestSet) -> Result {
        let file_contents = self.generate_prost(module_request_set)?;
        Ok(module_request_set
            .requests()
            .filter_map(|(module, request)| {
                self.generate_one(module, request, &file_contents)
                    .transpose()
            })
            .collect::<std::result::Result<Vec<_>, Error>>()?
            .iter()
            .flatten()
            .cloned()
            .collect())
    }
}

impl ProstValidateGenerator {
    pub fn new(config: prost_build::Config, insert_include: bool) -> Self {
        Self {
            builder: Builder::new(),
            config,
            insert_include,
        }
    }

    fn generate_prost(
        &mut self,
        module_request_set: &ModuleRequestSet,
    ) -> std::result::Result<HashMap<Module, String>, Error> {
        // we need to generate a raw file descriptor set in order to build prost-reflect the descriptor pool
        // otherwise we can't annotate the config due to missing options in the prost crates.
        let file_descriptor_set_bytes = RawProtosSet {
            file: module_request_set
                .requests()
                .map(|(_, request)| request.raw_files())
                .flatten()
                .map(|f| f.to_vec())
                .collect::<Vec<_>>(),
        }
        .encode_to_vec();
        let pool = DescriptorPool::decode(file_descriptor_set_bytes.as_slice())?;

        self.builder.annotate(&mut self.config, &pool);
        let prost_requests: Vec<_> = module_request_set
            .requests()
            .flat_map(|(module, request)| {
                request.files().map(|proto| (module.clone(), proto.clone()))
            })
            .collect();

        Ok(self.config.generate(prost_requests)?)
    }

    fn generate_one(
        &mut self,
        module: &Module,
        request: &ModuleRequest,
        file_contents: &HashMap<Module, String>,
    ) -> std::result::Result<Option<Vec<File>>, Error> {
        let content = match file_contents.get(module) {
            Some(content) => content,
            None => return Ok(None),
        };
        let output_filename = format!("{}.validate.rs", request.proto_package_name());

        let mut file_stream = TokenStream::new();
        syn::parse_file(content)
            .expect("failed to parse generated file")
            .items
            .iter()
            .filter_map(filter_item)
            .map(|stream| prost_validate_derive_core::derive(stream))
            .for_each(|stream| stream.to_tokens(&mut file_stream));

        if file_stream.is_empty() {
            return Ok(None);
        }

        let mut res = Vec::with_capacity(2);
        if self.insert_include {
            // only include file if it is part of the proto generation request
            res.push(
                match request.append_to_file(|buf| {
                    buf.push_str("include!(\"");
                    buf.push_str(&output_filename);
                    buf.push_str("\");\n");
                }) {
                    Some(file) => file,
                    None => return Ok(None),
                },
            );
        }

        let file = syn::parse_file(file_stream.to_string().as_str())?;
        let content = format!(
            "// @generated by protoc-gen-prost-validate\n{}",
            prettyplease::unparse(&file).as_str()
        );
        res.push(File {
            name: Some(output_filename.clone()),
            content: Some(content),
            ..File::default()
        });
        Ok(Some(res))
    }
}

fn filter_item(item: &syn::Item) -> Option<TokenStream> {
    match item {
        syn::Item::Struct(s) => {
            if has_validator_derive(&s.attrs) {
                Some(item.to_token_stream())
            } else {
                None
            }
        }
        syn::Item::Enum(e) => {
            if has_validator_derive(&e.attrs) {
                Some(item.to_token_stream())
            } else {
                None
            }
        }
        _ => None,
    }
}

fn has_validator_derive(attrs: &Vec<syn::Attribute>) -> bool {
    let mut has_validator = false;
    for attr in attrs {
        if attr.path().is_ident("derive") {
            let _ = attr.parse_nested_meta(|meta| {
                has_validator =
                    meta.path.to_token_stream().to_string() == ":: prost_validate :: Validator";
                Ok(())
            });
        }
        if has_validator {
            return true;
        }
    }
    false
}

#[derive(Clone, PartialEq, ::prost::Message)]
struct RawProtosSet {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub file: Vec<Vec<u8>>,
}
